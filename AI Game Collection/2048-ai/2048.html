<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2048 Smart Heuristic AI</title>
<style>
  body { font-family: Arial, sans-serif; background: #222; color: #fff; display:flex; flex-direction:column; align-items:center; padding:20px;}
  h1 { margin-bottom: 10px; }
  #status { margin: 10px 0; font-size:18px;}
  #grid { display:grid; grid-template-columns:repeat(4,80px); grid-template-rows:repeat(4,80px); gap:10px; }
  .cell { width:80px; height:80px; background:#333; display:flex; align-items:center; justify-content:center; font-size:24px; font-weight:bold; border-radius:8px; }
  .cell[data-value="0"] { background:#333; }
  .cell[data-value="2"] { background:#eee; color:#111;}
  .cell[data-value="4"] { background:#ddd; color:#111;}
  .cell[data-value="8"] { background:#f96; }
  .cell[data-value="16"] { background:#f65; }
  .cell[data-value="32"] { background:#f53; }
  .cell[data-value="64"] { background:#f32; }
  .cell[data-value="128"] { background:#ff0; color:#111; }
  .cell[data-value="256"] { background:#fc0; color:#111; }
  .cell[data-value="512"] { background:#fa0; color:#111; }
  .cell[data-value="1024"] { background:#f90; color:#111; }
  .cell[data-value="2048"] { background:#f80; color:#111; }
  button { margin:5px; padding:10px 15px; border-radius:5px; border:none; cursor:pointer; font-size:16px;}
</style>
</head>
<body>
<h1>2048 Smart Heuristic AI</h1>
<div id="status">Score: 0</div>
<div id="grid"></div>
<div>
  <button id="btnAI">Step AI</button>
  <button id="btnFastAI">Instant AI</button>
  <button id="btnRestart">Restart</button>
</div>

<script>
const SIZE = 4;
let grid = [];
let score = 0;
let gameOver = false;
let aiInterval = null;

const gridDiv = document.getElementById('grid');
const statusDiv = document.getElementById('status');
const btnAI = document.getElementById('btnAI');
const btnFastAI = document.getElementById('btnFastAI');
const btnRestart = document.getElementById('btnRestart');

function init() {
  grid = Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  score = 0; gameOver = false;
  updateStatus();
  spawnTile();
  spawnTile();
  render();
}

function updateStatus() {
  statusDiv.textContent = `Score: ${score}${gameOver ? ' - Game Over' : ''}`;
}

function render() {
  gridDiv.innerHTML = '';
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const val = grid[r][c];
      const cell = document.createElement('div');
      cell.className='cell';
      cell.dataset.value=val;
      cell.textContent = val===0?'':val;
      gridDiv.appendChild(cell);
    }
  }
}

function spawnTile() {
  let empty = [];
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(grid[r][c]===0) empty.push([r,c]);
    }
  }
  if(empty.length===0) return;
  const [r,c] = empty[Math.floor(Math.random()*empty.length)];
  grid[r][c] = Math.random()<0.9?2:4;
}

function cloneGrid(g) { return g.map(row=>row.slice()); }

function move(dir){
  let moved = false;
  let merged = Array.from({length:SIZE},()=>Array(SIZE).fill(false));
  function slide(r,c,dr,dc){
    let nr=r+dr, nc=c+dc;
    while(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
      if(grid[nr][nc]===0) {
        grid[nr][nc]=grid[r][c]; grid[r][c]=0; r=nr; c=nc; nr+=dr; nc+=dc; moved=true;
      } else if(grid[nr][nc]===grid[r][c] && !merged[nr][nc] && !merged[r][c]) {
        grid[nr][nc]*=2; score+=grid[nr][nc]; grid[r][c]=0; merged[nr][nc]=true; moved=true; break;
      } else break;
    }
  }

  if(dir==='left'){ for(let r=0;r<SIZE;r++) for(let c=1;c<SIZE;c++) if(grid[r][c]) slide(r,c,0,-1);}
  else if(dir==='right'){ for(let r=0;r<SIZE;r++) for(let c=SIZE-2;c>=0;c--) if(grid[r][c]) slide(r,c,0,1);}
  else if(dir==='up'){ for(let c=0;c<SIZE;c++) for(let r=1;r<SIZE;r++) if(grid[r][c]) slide(r,c,-1,0);}
  else if(dir==='down'){ for(let c=0;c<SIZE;c++) for(let r=SIZE-2;r>=0;r--) if(grid[r][c]) slide(r,c,1,0);}
  
  if(moved) spawnTile();
  if(!canMove()) gameOver=true;
  updateStatus();
  render();
  return moved;
}

function canMove(){
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(grid[r][c]===0) return true;
      if(c<SIZE-1 && grid[r][c]===grid[r][c+1]) return true;
      if(r<SIZE-1 && grid[r][c]===grid[r+1][c]) return true;
    }
  }
  return false;
}

// Smarter heuristic AI
function aiMove(){
  const moves=['up','down','left','right'];
  let bestScore = -Infinity;
  let bestMove = null;
  for(const m of moves){
    let clone = cloneGrid(grid);
    let tempScore = score;
    if(simulateMove(clone,m)){
      let heur = evaluate(clone);
      if(heur>bestScore){ bestScore=heur; bestMove=m; }
    }
  }
  if(bestMove) move(bestMove);
}

function simulateMove(g,dir){
  let moved=false;
  let merged = Array.from({length:SIZE},()=>Array(SIZE).fill(false));
  function slide(r,c,dr,dc){
    let nr=r+dr, nc=c+dc;
    while(nr>=0 && nr<SIZE && nc>=0 && nc<SIZE){
      if(g[nr][nc]===0){ g[nr][nc]=g[r][c]; g[r][c]=0; r=nr; c=nc; nr+=dr; nc+=dc; moved=true; }
      else if(g[nr][nc]===g[r][c] && !merged[nr][nc] && !merged[r][c]){ g[nr][nc]*=2; g[r][c]=0; merged[nr][nc]=true; moved=true; break; }
      else break;
    }
  }
  if(dir==='left'){ for(let r=0;r<SIZE;r++) for(let c=1;c<SIZE;c++) if(g[r][c]) slide(r,c,0,-1);}
  else if(dir==='right'){ for(let r=0;r<SIZE;r++) for(let c=SIZE-2;c>=0;c--) if(g[r][c]) slide(r,c,0,1);}
  else if(dir==='up'){ for(let c=0;c<SIZE;c++) for(let r=1;r<SIZE;r++) if(g[r][c]) slide(r,c,-1,0);}
  else if(dir==='down'){ for(let c=0;c<SIZE;c++) for(let r=SIZE-2;r>=0;r--) if(g[r][c]) slide(r,c,1,0);}
  return moved;
}

// Evaluation function: empty + monotonicity + smoothness + max in corner
function evaluate(g){
  let empty=0, smooth=0, mono=0, maxTile=0;
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      let val=g[r][c];
      if(val===0) empty++;
      if(val>maxTile) maxTile=val;
      if(c<SIZE-1 && val && g[r][c+1]) smooth -= Math.abs(val - g[r][c+1]);
      if(r<SIZE-1 && val && g[r+1][c]) smooth -= Math.abs(val - g[r+1][c]);
    }
  }
  // Monotonicity (rows)
  for(let r=0;r<SIZE;r++){
    let inc=true, dec=true;
    for(let c=1;c<SIZE;c++){
      if(g[r][c-1]>g[r][c]) inc=false;
      if(g[r][c-1]<g[r][c]) dec=false;
    }
    if(inc||dec) mono+=1;
  }
  // Monotonicity (cols)
  for(let c=0;c<SIZE;c++){
    let inc=true, dec=true;
    for(let r=1;r<SIZE;r++){
      if(g[r-1][c]>g[r][c]) inc=false;
      if(g[r-1][c]<g[r][c]) dec=false;
    }
    if(inc||dec) mono+=1;
  }
  // Max in corner bonus
  let cornerBonus=0;
  const corners=[[0,0],[0,SIZE-1],[SIZE-1,0],[SIZE-1,SIZE-1]];
  for(const [r,c] of corners){
    if(g[r][c]===maxTile) cornerBonus=4;
  }
  return empty*2 + smooth + mono*1.5 + cornerBonus*maxTile;
}

btnAI.addEventListener('click', ()=>{
  if(gameOver) return;
  if(aiInterval) clearInterval(aiInterval);
  aiInterval=setInterval(()=>{
    if(!gameOver){ aiMove(); } else clearInterval(aiInterval);
  },200);
});

btnFastAI.addEventListener('click', ()=>{
  if(gameOver) return;
  while(!gameOver){ aiMove(); }
});

btnRestart.addEventListener('click', ()=>{
  if(aiInterval) clearInterval(aiInterval);
  init();
});

// Arrow keys
document.addEventListener('keydown', (e)=>{
  if(gameOver) return;
  if(e.key==='ArrowUp') move('up');
  if(e.key==='ArrowDown') move('down');
  if(e.key==='ArrowLeft') move('left');
  if(e.key==='ArrowRight') move('right');
});

init();
</script>
</body>
</html>
